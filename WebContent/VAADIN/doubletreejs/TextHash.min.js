/* (This is the new BSD license.)
* Copyright (c) 2012, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/"use strict";

var doubletree = doubletree || {};

(function() {
  doubletree.TextHash = function(string, caseSensitive, fldNames, fldDelim, distinguishingFldsArray, baseField) {
    function convertItem(inItem) {
      var flds = inItem.split(fieldDelim);
      var item = flds[that.baseFieldIdx];
      if (!caseSensitive) {
        item = item.toLocaleLowerCase();
      }
      for (var f in flds) {
        if (f == that.baseFieldIdx) {
          continue;
        }
        if (distinguishingFieldsArray.indexOf(fldNames[f]) > -1) {
          item += "" + fldDelim + flds[f];
        }
      }
      return item;
    }
    var that = this;
    this.baseField = baseField;
    this.baseFieldIdx = fldNames.indexOf(baseField);
    if (this.baseFieldIdx == -1) {
      this.baseFieldIdx = 0;
    }
    this.items = string.replace(/\s*\n\s*/g, " ").trim().split(" ");
    this.indices = {};
    this.numTypes = 0;
    this.numTokens = this.items.length;
    var numItems = this.items.length;
    var lastItem = numItems - 1;
    if (string != "") {
      for (var i = 0; i < numItems; i++) {
        var item = convertItem(this.items[i]);
        if (!(item in this.indices && this.indices[item] instanceof Array)) {
          this.indices[item] = [];
        }
        try {
          this.indices[item].push(i);
        } catch (e) {
          console.log("Couldn't add: " + item);
        }
      }
    }
    this.numTypes = Object.keys(this.indices).length;
    this.containsItem = function(item) {
      return convertItem(item) in this.indices;
    };
    this.containsIndex = function(item) {
      return item in this.indices;
    };
    this.getItem = function(item, contextLen, includeOnly) {
      var prefixArray = [], itemArray = [], suffixArray = [], idArray = [];
      var numItems = this.items.length;
      var lastItem = numItems - 1;
      var hits = this.indices[item];
      var n = hits.length;
      var nMinus1 = n - 1;
      for (var i = 0; i < n; i++) {
        if (includeOnly != null && !(i in includeOnly)) {
          continue;
        }
        idArray.push(i);
        var thisIndex = hits[i];
        var origItem = this.items[thisIndex];
        itemArray.push(origItem);
        if (thisIndex == 0) {
          prefixArray.push([]);
        } else {
          var pStart = Math.max(0, thisIndex - contextLen);
          prefixArray.push(this.items.slice(pStart, thisIndex));
        }
        if (thisIndex == nMinus1) {
          suffixArray.push([]);
        } else {
          var sEnd = Math.min(lastItem, thisIndex + contextLen);
          suffixArray.push(this.items.slice(thisIndex + 1, sEnd + 1));
        }
      }
      return [ prefixArray, itemArray, suffixArray, idArray ];
    };
    this.getItemContext = function(item, contextLen, id) {
      var toGet = {};
      toGet[id] = true;
      var results = this.getItem(item, contextLen, toGet);
      var what = results[0][0].join(" ") + " " + item + " " + results[2][0].join(" ");
      return what;
    };
    this.getUniqItems = function() {
      return Object.keys(this.indices).sort(function(A, B) {
        var a = A.toLocaleLowerCase();
        var b = B.toLocaleLowerCase();
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      });
    };
    this.getUniqItemsWithCounts = function() {
      var what = [];
      for (item in this.indices) {
        what.push(item + "	" + this.indices[item].length);
      }
      what.sort(function(A, B) {
        var a = A.toLocaleLowerCase();
        var b = B.toLocaleLowerCase();
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      });
      return what;
    };
    this.fromJSON = function(obj) {
      this.baseField = obj.baseField;
      this.baseFieldIdx = obj.baseFieldIdx;
      this.items = obj.items;
      this.indices = obj.indices;
      this.numTypes = obj.numTypes;
      this.numTokens = obj.numTokens;
    };
    this.itemToIndex = function(item) {
      return convertItem(item);
    };
  };
})();